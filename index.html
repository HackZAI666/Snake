<!doctype html>
<html lang="en-US">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Snake v0.6 â€” Difficulty: Regular / Classified / Top Secret (v2)</title>
<style>
  :root{--bg:#e8f8e6;--panel:rgba(0,0,0,0.6);--accent:#2e8ef7}
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;background:var(--bg);color:#222;overflow:hidden}
  #canvas{display:block;background:var(--bg)}
  #lobby{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:16px;background:transparent;z-index:50}
  .logo{font-weight:900;font-size:48px;letter-spacing:6px;color:#111}
  .subtitle{color:#555;font-size:14px}
  .menu{display:flex;gap:10px;align-items:center}
  .btn{padding:12px 18px;border-radius:8px;border:0;background:var(--accent);color:white;font-weight:600;cursor:pointer;font-size:16px}
  .btn.secondary{background:transparent;border:1px solid rgba(0,0,0,0.08);color:#222}
  .big-btn{padding:18px 22px;font-size:18px;border-radius:12px}
  #leaderboard{position:fixed;right:12px;top:12px;background:var(--panel);color:#fff;padding:10px;border-radius:8px;min-width:200px;z-index:20;font-size:13px}
  #hud{display:none;position:fixed;left:12px;bottom:12px;background:var(--panel);color:#fff;padding:8px;border-radius:8px;z-index:20;font-size:13px;min-width:220px}
  #notice{position:fixed;left:50%;transform:translateX(-50%);top:14px;background:rgba(0,0,0,0.55);color:#fff;padding:8px 12px;border-radius:999px;font-size:13px;z-index:25}
  #debugErr{position:fixed;right:12px;bottom:12px;background:rgba(255,0,0,0.85);color:#fff;padding:8px;border-radius:6px;font-size:12px;display:none;z-index:100}
  .progress-bar{background:rgba(255,255,255,0.14);height:8px;border-radius:6px;overflow:hidden;margin-top:6px}
  .progress-inner{height:100%;border-radius:6px;background:linear-gradient(90deg,var(--accent),#4fb3ff)}
  #joyWrap{position:fixed;left:16px;bottom:16px;width:150px;height:150px;border-radius:999px;background:rgba(46,142,247,0.08);display:none;z-index:70;touch-action:none}
  #joyPad{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:88px;height:88px;border-radius:999px;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center}
  #joyKnob{width:40px;height:40px;border-radius:999px;background:rgba(46,142,247,0.22);box-shadow:0 6px 12px rgba(0,0,0,0.12);touch-action:none}
  #joyToggleWrap{display:flex;align-items:center;gap:8px;margin-right:6px;color:#333;font-size:13px}
  .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center;z-index:80}
  .modal{background:#fff;padding:18px;border-radius:12px;min-width:360px;max-width:520px;box-shadow:0 10px 30px rgba(0,0,0,0.2)}
  .modal h3{margin:0 0 12px 0}
  .modal .row{display:flex;gap:8px;align-items:center;margin-bottom:10px}
  .room-code{font-weight:900;font-size:36px;letter-spacing:6px;text-align:center;background:linear-gradient(90deg,#eefaff,#f0fff6);padding:10px;border-radius:8px}
  .opt{display:flex;align-items:center;gap:10px}
  .muted{color:#666;font-size:13px}
  input[type="text"]{padding:10px;border-radius:8px;border:1px solid #ddd;outline:none}
  #respawnBtn{display:none}
  @media (max-width:900px){
    #respawnBtn{display:block; position:fixed; right:16px; bottom:86px; z-index:90}
  }
  .big-instructions{
    font-size:18px;
    font-weight:700;
    color:#222;
    text-align:center;
    max-width:820px;
    padding:10px 14px;
    background: rgba(255,255,255,0.6);
    border-radius:10px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.08);
    margin-top:6px;
    line-height:1.4;
    letter-spacing:0.2px;
  }
  @media (max-width:640px){
    .big-instructions{ font-size:15px; padding:8px 10px; max-width:92%; }
  }
  #credit{position:fixed;right:12px;bottom:12px;z-index:30;background:rgba(0,0,0,0.45);color:#fff;padding:6px 10px;border-radius:8px;font-size:13px;font-weight:600;pointer-events:none;user-select:none;}
  @media (max-width:420px){#credit{ font-size:12px; padding:5px 8px; right:10px; bottom:56px; }}
  #difficultyBackdrop .modal{min-width:300px; text-align:center}
  #difficultyBtns{display:flex;gap:12px;justify-content:center;margin-top:8px}
  #difficultyBtns .btn{min-width:120px}
</style>
</head>
<body>

<div id="lobby" aria-hidden="true">
  <div class="logo">Snake v0.6</div>
  <div class="subtitle" style="font-weight:600">WASD controls Â· O to respawn Â· Eat pellets to grow</div>
  <div class="menu">
    <label id="joyToggleWrap"><input id="joyToggle" type="checkbox"> Enable virtual joystick</label>
    <button id="startBtn" class="btn">Start Game</button>
    <button id="multBtn" class="btn secondary">Multiplayer (placeholder)</button>
  </div>

  <div class="big-instructions" id="bigInstructions">
    Use WASD to control your snake. Avoid other snakes' bodies â€” they will try to trap you. Higher difficulties make AI smarter and more tactical.
  </div>

  <div style="font-size:13px;color:#444">Tip: On mobile, enable the virtual joystick.</div>
</div>

<canvas id="canvas"></canvas>
<div id="credit" aria-hidden="true">game made by John Li</div>
<div id="leaderboard" style="display:none"></div>
<div id="hud" style="display:none"></div>
<div id="notice" style="display:none"></div>
<div id="debugErr"></div>
<button id="respawnBtn" class="btn big-btn" aria-hidden="true">Respawn (O)</button>
<div id="joyWrap" aria-hidden="true"><div id="joyPad"><div id="joyKnob"></div></div></div>

<div id="difficultyBackdrop" class="modal-backdrop">
  <div class="modal">
    <h3>Choose difficulty</h3>
    <div class="muted">Regular = baseline. Classified = very hard. Top Secret = extreme (boss-focused, brutal).</div>
    <div id="difficultyBtns">
      <button id="diffRegular" class="btn">Regular</button>
      <button id="diffClassified" class="btn secondary">Classified</button>
      <button id="diffTopSecret" class="btn secondary">Top Secret</button>
    </div>
    <div style="text-align:right;margin-top:12px;"><button id="diffCancel" class="btn secondary">Cancel</button></div>
  </div>
</div>

<script>
// ===== debug =====
window.addEventListener('error', (ev) => {
  try{ const dbg = document.getElementById('debugErr'); if(dbg){ dbg.style.display='block'; dbg.innerText = 'ERROR: ' + (ev.message||ev) + ' @ ' + (ev.filename||'') + ':' + (ev.lineno||''); } }catch(e){console.error(e);} console.error('Unhandled error:', ev);
});

// ===== constants & mutable =====
const SPEED_SLOW_START = 17000;
const SLOW_K = 0.00007;
const SLOW_CAP_SEG = 100000;
const MAP_HALF = 4200;
const BORDER_PADDING = 80;
const GRID_SIZE = 90;
const ORIGINAL_GROW_SCALE = 7;
const SIZE_GROW_MULT = 5;
const SEGMENTS_FOR_ONE_GRID = 700;
const EFF_PER_GRID = (SEGMENTS_FOR_ONE_GRID * SIZE_GROW_MULT) / ORIGINAL_GROW_SCALE;
const BASE_RADIUS = 10;
let NUM_AI = 40;
const INITIAL_BIG_SNAKES = 1;
const RESPAWN_MS = 10000;
const PELLET_RADIUS = 6;
let PELLET_TTL = 60 * 1000;
const SPAWN_INVUL_MS = 0;
const MAX_WIDTH_BLOCKS = 10;
const ORIGINAL_BURST_BASE = 1.35;
const TOP_BURST_MULTIPLIER = ORIGINAL_BURST_BASE * 12.0;
const MAX_ABSOLUTE_SPEED = 9.0;
const INITIAL_SPEED_BOOST = 1.02;
const MAX_BASE_SPEED_CAP = 5.2;

const MAX_RENDER_SEGS = 1200;
const MAX_SPACING_MULT = 1.12;
const AI_SMART_BOOST = 0.12;

let ENABLE_PVP = true;
let PELLET_YIELD_MULT = 1.0;
let PLAYER_PRIORITY = 0.9;
let PREFER_ATTACK_OTHERS = 0.62;

// boss globals
let worldBoss = null; let bossProjectiles = []; let bossRockets = [];
const BOSS_TRIGGER_SEGMENTS = 1000; // player size threshold

const DIFF_REGULAR = 'regular';
const DIFF_CLASSIFIED = 'classified';
const DIFF_TOPSECRET = 'topsecret';

// UI refs
const canvas = document.getElementById('canvas'); const ctx = canvas.getContext('2d');
let W = window.innerWidth, H = window.innerHeight; canvas.width = W; canvas.height = H;
const lobby = document.getElementById('lobby'); const startBtn = document.getElementById('startBtn'); const multBtn = document.getElementById('multBtn');
const difficultyBackdrop = document.getElementById('difficultyBackdrop'); const diffRegular = document.getElementById('diffRegular'); const diffClassified = document.getElementById('diffClassified'); const diffTopSecret = document.getElementById('diffTopSecret'); const diffCancel = document.getElementById('diffCancel');
const leaderboardEl = document.getElementById('leaderboard'); const hud = document.getElementById('hud'); const notice = document.getElementById('notice'); const debugErr = document.getElementById('debugErr'); const respawnBtn = document.getElementById('respawnBtn');
const joyToggle = document.getElementById('joyToggle'); const joyWrap = document.getElementById('joyWrap'); const joyKnob = document.getElementById('joyKnob');

let camX = 0, camY = 0; const keys = { w:false,a:false,s:false,d:false,ArrowUp:false,ArrowLeft:false,ArrowDown:false,ArrowRight:false };

window.addEventListener('keydown', e=>{ if(e.code==='KeyW') keys.w = true; if(e.code==='KeyA') keys.a = true; if(e.code==='KeyS') keys.s = true; if(e.code==='KeyD') keys.d = true; if(e.code==='ArrowUp') keys.ArrowUp = true; if(e.code==='ArrowLeft') keys.ArrowLeft = true; if(e.code==='ArrowDown') keys.ArrowDown = true; if(e.code==='ArrowRight') keys.ArrowRight = true; });
window.addEventListener('keyup', e=>{ if(e.code==='KeyW') keys.w = false; if(e.code==='KeyA') keys.a = false; if(e.code==='KeyS') keys.s = false; if(e.code==='KeyD') keys.d = false; if(e.code==='ArrowUp') keys.ArrowUp = false; if(e.code==='ArrowLeft') keys.ArrowLeft = false; if(e.code==='ArrowDown') keys.ArrowDown = false; if(e.code==='ArrowRight') keys.ArrowRight = false; });

window.addEventListener('keydown', e=>{
  if(e.code === 'KeyO'){
    try{
      const ae = document.activeElement;
      const tag = ae && ae.tagName ? ae.tagName.toUpperCase() : '';
      const isTyping = tag === 'INPUT' || tag === 'TEXTAREA' || (ae && ae.isContentEditable);
      if(!isTyping) attemptRespawn();
    }catch(err){ console.error('respawn key handler error', err); }
  }
});

// helpers
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function lerp(a,b,t){ return a + (b - a) * t; }
function randomColor(){ return 'hsl(' + Math.floor(Math.random()*360) + ',68%,55%)'; }
function showNotice(txt){ notice.innerText = txt; notice.style.display = 'block'; noticeTimer = Date.now() + 1600; }
function worldToScreen(wx, wy){ return { x: Math.round((wx - camX) + W/2), y: Math.round((wy - camY) + H/2) }; }
function colorWithAlpha(hsl,a){ return hsl.replace('hsl(', 'hsla(').replace(')', ', ' + a + ')'); }

let pellets = []; let snakes = []; let playerSnake = null;

class Snake {
  constructor(id,x,y,color,isAI=false, params={}){
    this.id = id; this.head = { x:x, y:y, angle: Math.random()*Math.PI*2 }; this.prevHead = { x:x, y:y }; this.color = color || randomColor(); this.isAI = isAI; this.alive = true; this.segs = []; this.spawnTime = Date.now(); this.spawnInvulnerableUntil = Date.now() + SPAWN_INVUL_MS;
    this.dodgeSkill = params.dodgeSkill ?? 0.9; this.bodyConsumeProb = params.bodyConsumeProb ?? 0.08; this.aiStrength = (params.aiStrength ?? 1.0) * 0.95; this.thicknessMultiplier = params.thicknessMultiplier ?? 1.0; this.isCircler = false; this._initialParams = Object.assign({}, params);
    if(params.segmentCount != null){ this.segmentCount = params.segmentCount; } else if(!isAI){ this.segmentCount = 18 + Math.floor(Math.random()*12); } else {
      const r = Math.random(); if(r < 0.28) this.segmentCount = 8 + Math.floor(Math.random()*24); else if(r < 0.65) this.segmentCount = 36 + Math.floor(Math.random()*70); else if(r < 0.92) this.segmentCount = 90 + Math.floor(Math.random()*140); else this.segmentCount = 180 + Math.floor(Math.random()*1820);
    }
    const baseSpeedRaw = (4.2 + Math.random()*0.8) * INITIAL_SPEED_BOOST; const sizeFactor = 1 + Math.log10(Math.max(1, this.segmentCount)) * 0.12 + (this.thicknessMultiplier - 1) * 0.12; this.speedBase = clamp(baseSpeedRaw / sizeFactor, 0.9, MAX_BASE_SPEED_CAP);
    this.displaySpeed = this.speedBase; this.score = 0; this.type = params.type || (isAI? 'ai':'player'); this.respawnAt = 0; this.burstUntil = 0; if(params.burstMultiplier != null) this.burstMultiplier = params.burstMultiplier; else this.burstMultiplier = 1.15 * this.aiStrength; this.visualRadius = BASE_RADIUS; this._physRadius = BASE_RADIUS;
    const initialRendered = Math.min(this.segmentCount, MAX_RENDER_SEGS); for(let i=0;i<initialRendered;i++) this.segs.push({x:this.head.x,y:this.head.y});
  }
  effectiveCount(){ return Math.max(0, (this.segmentCount * SIZE_GROW_MULT) / ORIGINAL_GROW_SCALE); }
  computeTargetRadius(){ const grids = this.segmentCount / SEGMENTS_FOR_ONE_GRID; const targetRadiusFromGrid = grids * (GRID_SIZE / 2); const target = Math.max(BASE_RADIUS, targetRadiusFromGrid); const maxRadius = (MAX_WIDTH_BLOCKS * GRID_SIZE) / 2; return Math.min(target, maxRadius); }
  radius(){ return this._physRadius; }
  segSpacing(){ return Math.max(6, this.visualRadius * 0.78); }
  calcTargetSpeed(){ let s = Math.max(0.12, this.speedBase); if(this.segmentCount > SPEED_SLOW_START){ const capped = Math.min(this.segmentCount, SLOW_CAP_SEG); const extra = (capped - SPEED_SLOW_START); s = Math.max(0.10, this.speedBase - extra * SLOW_K); } if(this.burstUntil && Date.now() < this.burstUntil){ s *= this.burstMultiplier; } s = Math.min(s, MAX_ABSOLUTE_SPEED); return s; }
  currentSpeed(){ return this.displaySpeed; }
  updateDisplaySpeed(dt){ const target = this.calcTargetSpeed(); const smooth = 0.12; this.displaySpeed = lerp(this.displaySpeed, target, smooth); }
  grow(n){ this.prevHead.x = this.head.x; this.prevHead.y = this.head.y; this.segmentCount += n; const want = Math.min(this.segmentCount, MAX_RENDER_SEGS); while(this.segs.length < want){ const tail = this.segs[this.segs.length-1] || {x:this.head.x,y:this.head.y}; this.segs.push({ x: tail.x, y: tail.y }); } }
  shrinkToSmall(){ this.segmentCount = 10 + Math.floor(Math.random()*10); const targetRendered = Math.min(this.segmentCount, MAX_RENDER_SEGS); this.segs.length = Math.min(this.segs.length, targetRendered); while(this.segs.length < targetRendered){ const tail = this.segs[this.segs.length-1] || {x:this.head.x,y:this.head.y}; this.segs.push({ x: tail.x, y: tail.y }); } const baseSpeedRaw = (4.2 + Math.random()*0.8) * INITIAL_SPEED_BOOST; this.speedBase = clamp(baseSpeedRaw, 0.9, MAX_BASE_SPEED_CAP); this.displaySpeed = this.speedBase; }
  updateRadii(dt){ const target = this.computeTargetRadius(); const visualLerp = 0.045; const physLerp = 0.08; this.visualRadius = lerp(this.visualRadius, target, visualLerp); this._physRadius = lerp(this._physRadius, target, physLerp); }
}

function shuffleArray(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i], a[j]] = [a[j], a[i]]; } return a; }

function makeAITiers(){ const arr = []; for(let i=0;i<2;i++) arr.push({ tier:'dumb', dodgeSkill:0.56 + Math.random()*0.10, bodyConsumeProb:0.02 + Math.random()*0.03, aiStrength:0.82, thicknessChance:0.08 }); for(let i=0;i<15;i++) arr.push({ tier:'basic', dodgeSkill:0.82 + (Math.random()*0.06), bodyConsumeProb:0.03 + Math.random()*0.04, aiStrength:0.96, thicknessChance:0.14 }); for(let i=0;i<13;i++) arr.push({ tier:'skilled', dodgeSkill:0.92 + Math.random()*0.04, bodyConsumeProb:0.06 + Math.random()*0.06, aiStrength:1.02, thicknessChance:0.22 }); for(let i=0;i<10;i++) arr.push({ tier:'top', dodgeSkill:0.96 + Math.random()*0.02, bodyConsumeProb:0.18 + Math.random()*0.12, aiStrength:1.08, thicknessChance:0.30 }); for(let i=0;i<Math.max(1, Math.floor(0.05*(2+15+13+10))); i++) arr.push({ tier:'risky', dodgeSkill:0.65 + Math.random()*0.18, bodyConsumeProb:0.28 + Math.random()*0.3, aiStrength:0.95, thicknessChance:0.12 }); return shuffleArray(arr); }

function findNearestEnemy(s, range=1400){ let best=null, bestd=Infinity; for(const other of snakes){ if(other===s || !other.alive) continue; const dx = other.head.x - s.head.x, dy = other.head.y - s.head.y; const d = Math.hypot(dx,dy); if(d < bestd && d <= range){ best = other; bestd = d; } } return best; }
function findNearestPellet(s, range=1400){ let best=null, bestd=Infinity; for(const p of pellets){ const dx = p.x - s.head.x, dy = p.y - s.head.y; const d = Math.hypot(dx,dy); if(d < bestd && d <= range){ best = p; bestd = d; } } return best; }

function pointToSegmentDistance(ax,ay,bx,by,cx,cy){ const vx = bx-ax, vy = by-ay; const wx = cx-ax, wy = cy-ay; const l2 = vx*vx + vy*vy; let t = 0; if(l2 > 0) t = (vx*wx + vy*wy) / l2; t = Math.max(0, Math.min(1, t)); const projx = ax + t * vx, projy = ay + t * vy; const dx = cx - projx, dy = cy - projy; return Math.hypot(dx,dy); }

// Tactical AI: classified & topsecret are much more strategic
function aiThink(s){
  if(!s.alive) return;
  const now = Date.now();
  if(s.isCircler){ if(Math.random() < 0.035) s.head.angle += (Math.random()-0.5)*1.1; }

  const isBig = (s.type==='big' || s.segmentCount > 900 || (s._initialParams && s._initialParams.type === 'big'));

  // intelligence boost for big snakes
  if(isBig){ s.dodgeSkill = Math.min(0.99, (s.dodgeSkill || 0.7) + AI_SMART_BOOST * 1.1); s.aiStrength = Math.min(1.4, (s.aiStrength || 1.0) + AI_SMART_BOOST * 0.9); }

  const borderSafe = MAP_HALF - BORDER_PADDING - 600;
  if(Math.abs(s.head.x) > borderSafe || Math.abs(s.head.y) > borderSafe){
    const away = Math.atan2( (Math.sign(s.head.y)* (MAP_HALF - BORDER_PADDING) - s.head.y), (Math.sign(s.head.x)*(MAP_HALF - BORDER_PADDING) - s.head.x) );
    s.head.angle = lerpAngle(s.head.angle, away + (Math.random()-0.5)*0.4, 0.22);
    if(Math.random() < 0.2) s.burstUntil = now + 280;
    return;
  }

  // avoid bigger threats â€” but classified/topsecret will be more willing to trade
  let nearestThreat = null, threatD = Infinity;
  for(const other of snakes){ if(other===s || !other.alive) continue; if(other.segmentCount > s.segmentCount * 0.9 && other.segmentCount > Math.max(200, s.segmentCount - 10)){ const d = Math.hypot(other.head.x - s.head.x, other.head.y - s.head.y); if(d < threatD){ threatD = d; nearestThreat = other; } } }
  if(nearestThreat && threatD < 900){
    const awayAng = Math.atan2(s.head.y - nearestThreat.head.y, s.head.x - nearestThreat.head.x);
    // stronger snakes try to flank and circle rather than pure fleeing
    if(s.segmentCount > 220 || s._initialParams && s._initialParams.type === 'big'){
      s.head.angle = lerpAngle(s.head.angle, awayAng + (Math.random()-0.5)*0.2, 0.18);
      if(Math.random() < 0.6) s.burstUntil = now + 420;
      return;
    }
    s.head.angle = lerpAngle(s.head.angle, awayAng + (Math.random()-0.5)*0.2, 0.28);
    if(Math.random() < 0.45) s.burstUntil = now + 360;
    return;
  }

  // target pellets if reasonable
  const pellet = findNearestPellet(s, isBig ? 2400 : 1400);
  if(pellet && Math.random() < (isBig ? 0.9 : 0.6)){
    s.head.angle = lerpAngle(s.head.angle, Math.atan2(pellet.y - s.head.y, pellet.x - s.head.x), 0.14);
    if(Math.random() < 0.06 * s.aiStrength) s.burstUntil = now + 220;
    return;
  }

  // detect nearby bodies (to eat) â€” but on higher difficulties AIs will prefer to use bodies strategically
  let nearestBody = null, nearestBodyD = Infinity;
  for(const other of snakes){ if(!other.alive) continue; const startIdx = 4; for(let i=startIdx;i<other.segs.length;i+= Math.max(1, Math.floor(other.segs.length / 30))){ const seg = other.segs[i]; const d = Math.hypot(seg.x - s.head.x, seg.y - s.head.y); if(d < nearestBodyD){ nearestBodyD = d; nearestBody = {x:seg.x,y:seg.y,owner:other}; } } }

  const avoidThreshold = 150 + s.visualRadius * 5;
  if(nearestBody && nearestBodyD < avoidThreshold){
    // On classified/topsecret, AI will NOT foolishly smash into player's body; they'll dodge and sometimes bait
    if(Math.random() < s.dodgeSkill){
      const awayAng = Math.atan2(s.head.y - nearestBody.y, s.head.x - nearestBody.x);
      s.head.angle = lerpAngle(s.head.angle, awayAng + (Math.sin(now/320)*0.6), 0.18);
      if(Math.random() < 0.12 * s.aiStrength) s.burstUntil = now + 160 + Math.random()*280; // occasional burst
      return;
    } else {
      // opportunistic body-eating still possible
      if(Math.random() < s.bodyConsumeProb * 1.4){
        s.head.angle = lerpAngle(s.head.angle, Math.atan2(nearestBody.y - s.head.y, nearestBody.x - s.head.x), 0.15);
        if(Math.random() < 0.48) s.burstUntil = now + 180;
        return;
      }
    }
  }

  // Player-targeting: more tactical on higher difficulties
  const player = playerSnake;
  const distToPlayer = player && player.alive ? Math.hypot(player.head.x - s.head.x, player.head.y - s.head.y) : Infinity;
  let choosePlayer = false;
  if(player && player.alive && distToPlayer < 2200){
    // on tougher difficulties increase chance to engage
    const engageProb = (s._initialParams && (currentDifficulty===DIFF_CLASSIFIED || currentDifficulty===DIFF_TOPSECRET)) ? 0.9 : 0.62;
    choosePlayer = Math.random() < (isBig ? 0.5 : engageProb);
  }

  if(choosePlayer){
    // Tactical behavior: attempt intercept + flank/encircle to force head-to-body collision.
    const playerVelX = Math.cos(player.head.angle) * (player.currentSpeed ? player.currentSpeed() : 1.0);
    const playerVelY = Math.sin(player.head.angle) * (player.currentSpeed ? player.currentSpeed() : 1.0);
    const leadFactor = clamp(0.8 + ((player.currentSpeed?player.currentSpeed():1.0) / 3.0), 0.8, 2.2);
    const leadDist = Math.min(1400, (player.currentSpeed?player.currentSpeed():1.0) * 26 * leadFactor + Math.min(700, distToPlayer * 0.08));
    const leadX = player.head.x + playerVelX * leadDist;
    const leadY = player.head.y + playerVelY * leadDist;

    // compute perpendicular offset to try to place body in front of player (encirclement)
    const perp = Math.atan2(player.head.y - s.head.y, player.head.x - s.head.x) + Math.PI/2;
    const offsetScale = (s.segmentCount > 120 ? Math.min(220, s.segmentCount/2) : 90);
    const encircleX = leadX + Math.cos(perp) * offsetScale * (Math.random() < 0.6 ? 1 : -1);
    const encircleY = leadY + Math.sin(perp) * offsetScale * (Math.random() < 0.6 ? 1 : -1);

    // stronger AIs will sometimes prefer to circle (isCircler) to set up body hits
    if((currentDifficulty === DIFF_CLASSIFIED || currentDifficulty === DIFF_TOPSECRET) && Math.random() < 0.45){
      s.isCircler = true;
      s.head.angle = lerpAngle(s.head.angle, Math.atan2(encircleY - s.head.y, encircleX - s.head.x), 0.16 + (isBig?0.06:0.0));
      if(Math.random() < 0.06 * s.aiStrength) s.burstUntil = now + 220 + Math.random()*160;
      return;
    }

    // otherwise do interception with some lateral offset to aim the head toward player's predicted path
    s.head.angle = lerpAngle(s.head.angle, Math.atan2(leadY - s.head.y, leadX - s.head.x), 0.12 + (isBig?0.05:0.0));
    if(Math.random() < 0.06 * s.aiStrength) s.burstUntil = now + 200;
    return;
  }

  // fallback: roam
  s.head.angle += (Math.random()-0.5)*0.016;
  if(s.isCircler && Math.random() < 0.008) s.isCircler = false;
}

function lerpAngle(a,b,t){ let diff=b-a; while(diff>Math.PI) diff-=Math.PI*2; while(diff<-Math.PI) diff+=Math.PI*2; return a+diff*t; }

// collisions, pellets, respawns (kept, with pellet yield mod)
function killSnake(victim, killer, reason){ if(!victim.alive) return; const now = Date.now(); if(reason && reason !== 'boundary' && !ENABLE_PVP) return; if((victim.spawnInvulnerableUntil && now < victim.spawnInvulnerableUntil) || (killer && killer.spawnInvulnerableUntil && now < killer.spawnInvulnerableUntil)) return; if(now - (victim.spawnTime || 0) < 100) return; victim.alive = false; victim.respawnAt = Date.now() + RESPAWN_MS; createPelletsFromVictim(victim); if(killer && killer.alive){ const rawGain = 4 + Math.floor(Math.random()*6); const gain = Math.max(1, Math.floor(rawGain / 2)); killer.prevHead.x = killer.head.x; killer.prevHead.y = killer.head.y; killer.grow(gain); killer.score = (killer.score || 0) + 1; const kname = killer.id || ('Player'+Math.floor(Math.random()*9999)); const vname = victim.id || ('Player'+Math.floor(Math.random()*9999)); showNotice(kname + ' killed ' + vname + ' +' + gain); } else { const vname = victim.id || ('Player'+Math.floor(Math.random()*9999)); showNotice(vname + ' died due to ' + (reason || 'unknown')); } }

function updatePelletPickup(){ if(pellets.length===0) return; for(let pi = pellets.length-1; pi>=0; pi--){ const p = pellets[pi]; for(const s of snakes){ if(!s.alive) continue; const rad = s.visualRadius; const dx = s.head.x - p.x, dy = s.head.y - p.y; const d = Math.hypot(dx,dy); if(d < rad + PELLET_RADIUS*0.8){ const val = p.value ?? 1.0; s.growthBuffer = (s.growthBuffer || 0) + val; while(s.growthBuffer >= 1.0){ s.growthBuffer -= 1.0; s.grow(1); } pellets.splice(pi,1); break; } } } const now = Date.now(); for(let i=pellets.length-1;i>=0;i--) if(now - pellets[i].created > PELLET_TTL) pellets.splice(i,1); }

function createPelletsFromVictim(victim){ const positions = (victim.segs && victim.segs.slice(0)) || []; if(!positions || positions.length < 2) return; const rawDesired = Math.floor((victim.segmentCount * 2) / 3); const desiredGain = Math.max(1, Math.floor(rawDesired * (PELLET_YIELD_MULT || 1))); const MAX_PELLETS = 200; const N = Math.min(MAX_PELLETS, Math.max(6, Math.min(desiredGain, 140))); const cum = [0]; let total = 0; for(let i=1;i<positions.length;i++){ const dx = positions[i].x - positions[i-1].x, dy = positions[i].y - positions[i-1].y; const d = Math.hypot(dx,dy); total += d; cum.push(total); } if(total <= 0){ for(let i=0;i<N;i++){ const angle = Math.random()*Math.PI*2; const r = 12 + Math.random()*Math.min(200, victim.visualRadius*1.2); const x = victim.head.x + Math.cos(angle)*r; const y = victim.head.y + Math.sin(angle)*r; const val = desiredGain / N; pellets.push({ x, y, color: victim.color, created: Date.now(), value: val }); } return; } for(let i=0;i<N;i++){ const t = (i + 0.5) / N; const targetLen = t * total; let idx = 0; while(idx < cum.length - 1 && cum[idx+1] < targetLen) idx++; const segStartLen = cum[idx]; const segEndLen = cum[idx+1] || segStartLen; const segLen = segEndLen - segStartLen; let frac = 0; if(segLen > 0) frac = (targetLen - segStartLen) / segLen; const p0 = positions[idx], p1 = positions[Math.min(idx+1, positions.length-1)]; const x = p0.x * (1-frac) + p1.x * frac; const y = p0.y * (1-frac) + p1.y * frac; const val = desiredGain / N; pellets.push({ x: x, y: y, color: victim.color, created: Date.now(), value: val }); } }

// ===== world boss improvements per your request =====
function spawnWorldBoss(mode='topsecret', nearX=null, nearY=null){
  if(worldBoss) return;
  const center = { x: nearX ?? (Math.random()*2-1)*(MAP_HALF/3), y: nearY ?? (Math.random()*2-1)*(MAP_HALF/3) };
  // make classified big, topsecret enormous (you wanted extremely large)
  const boss = { x: center.x, y: center.y, mode: mode, vx:0, vy:0, alive:true };
  if(mode === DIFF_CLASSIFIED){ boss.radius = 700; boss.hp = 2500; boss.maxHp = 2500; boss.speed = 0.06; boss.rocketDamage = 80; boss.rocketCount = 32; boss.rocketRingDist = boss.radius + 180; boss.nextRocketTime = Date.now() + 50000; boss.rocketInterval = 50000; }
  else { // topsecret
    boss.radius = 1400; boss.hp = 8500; boss.maxHp = 8500; boss.speed = 0.09; boss.rocketDamage = 40; boss.rocketCount = 36; boss.rocketRingDist = boss.radius + 260; boss.nextRocketTime = Date.now() + 80000; boss.rocketInterval = 80000;
  }
  // boss won't eat rockets; rockets are separate objects placed around
  worldBoss = boss; bossRockets = []; bossProjectiles = [];
  // spawn an initial (not-clustered) ring
  spawnRocketRing(worldBoss);
  showNotice('A massive threat has appeared nearby!');
}

function spawnRocketRing(boss){
  if(!boss) return;
  const count = boss.rocketCount || 24;
  const baseDist = boss.rocketRingDist || (boss.radius + 120);
  const jitter = Math.max(40, Math.floor(baseDist*0.12));
  for(let i=0;i<count;i++){
    const ang = (i / count) * Math.PI*2 + (Math.random()-0.5)*0.18;
    const dist = baseDist + (Math.random()-0.5) * jitter;
    const rx = boss.x + Math.cos(ang) * dist;
    const ry = boss.y + Math.sin(ang) * dist;
    // create rocket object with emoji-model placeholder
    bossRockets.push({ angle: ang, x: rx, y: ry, state:'idle', id: Date.now() + '_' + i, emoji: 'ðŸš€' });
  }
}

function updateWorldBoss(dt){
  if(!worldBoss || !worldBoss.alive) return;
  // wandering with larger roam radius
  // give the boss a stronger wandering force so it covers more area
  worldBoss.vx += (Math.random()-0.5) * 0.006;
  worldBoss.vy += (Math.random()-0.5) * 0.006;
  // damp
  worldBoss.vx *= 0.95;
  worldBoss.vy *= 0.95;
  const vmag = Math.hypot(worldBoss.vx, worldBoss.vy);
  if(vmag > worldBoss.speed){ worldBoss.vx = (worldBoss.vx / vmag) * worldBoss.speed; worldBoss.vy = (worldBoss.vy / vmag) * worldBoss.speed; }
  worldBoss.x += worldBoss.vx * dt * 60;
  worldBoss.y += worldBoss.vy * dt * 60;

  // boss moves over rockets but does not auto-destroy them
  for(const r of bossRockets){
    if(r.state === 'idle'){
      // gently orbit around boss center with some independent noise
      const dx = r.x - worldBoss.x; const dy = r.y - worldBoss.y;
      const ang = Math.atan2(dy,dx) + 0.002 * dt * (worldBoss.mode===DIFF_CLASSIFIED?0.6:1.0);
      const baseDist = Math.hypot(dx,dy);
      r.angle = ang;
      r.x = worldBoss.x + Math.cos(ang) * baseDist;
      r.y = worldBoss.y + Math.sin(ang) * baseDist;
    }
  }
  // projectiles update
  updateBossProjectiles(dt);
  // periodic rocket ring spawn (wider area) â€” spawn around boss every interval
  if(Date.now() >= (worldBoss.nextRocketTime || 0)){
    // spawn a slightly spread ring (not clustered)
    spawnRocketRing(worldBoss);
    worldBoss.nextRocketTime = Date.now() + (worldBoss.rocketInterval || 60000);
  }
}

function updateBossProjectiles(dt){
  for(let i=bossProjectiles.length-1;i>=0;i--){
    const p=bossProjectiles[i];
    p.x += p.vx * dt * 60;
    p.y += p.vy * dt * 60;
    const d = Math.hypot(p.x - worldBoss.x, p.y - worldBoss.y);
    if(d < worldBoss.radius * 0.92){
      worldBoss.hp -= p.damage;
      bossProjectiles.splice(i,1);
      for(let k=0;k<6;k++){
        const angle = Math.random()*Math.PI*2;
        const r = 6 + Math.random()*28;
        pellets.push({ x: worldBoss.x + Math.cos(angle)*r, y: worldBoss.y + Math.sin(angle)*r, color: '#ffdd88', created: Date.now(), value: 0.6 });
      }
      if(worldBoss.hp <= 0){
        worldBoss.alive = false;
        // reward scatter
        for(let j=0;j<400;j++){
          const angle = Math.random()*Math.PI*2;
          const rr = 12 + Math.random()*600;
          const val = 0.6 + Math.random()*2.6;
          pellets.push({ x: worldBoss.x + Math.cos(angle)*rr, y: worldBoss.y + Math.sin(angle)*rr, color: '#ffd27a', created: Date.now(), value: val });
        }
        showNotice('Boss defeated!');
        worldBoss=null; bossRockets=[]; bossProjectiles=[]; break;
      }
    } else {
      if(Math.hypot(p.x - worldBoss.x, p.y - worldBoss.y) > (worldBoss.rocketRingDist||1000) * 3){
        bossProjectiles.splice(i,1);
      }
    }
  }
}

function drawWorldBoss(){
  if(!worldBoss || !worldBoss.alive) return;
  const pos = worldToScreen(worldBoss.x, worldBoss.y);
  // shadow
  ctx.beginPath(); ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.arc(pos.x+8,pos.y+8, Math.round(worldBoss.radius*0.98), 0, Math.PI*2); ctx.fill();
  // body
  ctx.beginPath(); ctx.fillStyle = 'rgba(180,14,14,0.95)'; ctx.arc(pos.x,pos.y, worldBoss.radius, 0, Math.PI*2); ctx.fill();
  // spikes - many
  const spikeCount = 28;
  for(let i=0;i<spikeCount;i++){
    const a = (i / spikeCount) * Math.PI * 2 + (Date.now()/4000);
    const sx = pos.x + Math.cos(a) * (worldBoss.radius + 24);
    const sy = pos.y + Math.sin(a) * (worldBoss.radius + 24);
    ctx.beginPath(); ctx.moveTo(pos.x + Math.cos(a) * worldBoss.radius * 0.9, pos.y + Math.sin(a) * worldBoss.radius * 0.9);
    ctx.lineTo(sx, sy);
    ctx.lineTo(pos.x + Math.cos(a + 0.08) * worldBoss.radius * 0.9, pos.y + Math.sin(a + 0.08) * worldBoss.radius * 0.9);
    ctx.fillStyle = 'rgba(120,20,20,0.95)';
    ctx.fill();
  }
  // idle rockets (emoji-model) - spread out and not clustered
  for(const r of bossRockets){
    if(r.state === 'idle'){
      const rp = worldToScreen(r.x, r.y);
      ctx.beginPath(); ctx.fillStyle = 'rgba(70,120,255,0.98)'; ctx.arc(rp.x, rp.y, 12, 0, Math.PI*2); ctx.fill();
      ctx.font = '12px sans-serif'; ctx.textAlign = 'center'; ctx.fillStyle = '#fff'; ctx.fillText('ðŸš€', rp.x, rp.y+4);
    }
  }
  // projectiles
  for(const p of bossProjectiles){
    const pp = worldToScreen(p.x, p.y);
    ctx.beginPath(); ctx.fillStyle = 'rgba(255,120,60,0.95)'; ctx.arc(pp.x, pp.y, 8, 0, Math.PI*2); ctx.fill();
  }
  // hp bar
  const barW = Math.min(900, worldBoss.radius * 0.9);
  const px = pos.x - barW/2;
  const py = pos.y - worldBoss.radius - 26;
  ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(px-2, py-2, barW+4, 18);
  ctx.fillStyle = 'rgba(200,40,40,0.95)'; ctx.fillRect(px, py, Math.max(0, barW * (worldBoss.hp / worldBoss.maxHp)), 14);
  ctx.strokeStyle = 'rgba(255,255,255,0.18)'; ctx.strokeRect(px, py, barW, 14);
}

function handleBossRocketTriggers(){
  if(!worldBoss || !worldBoss.alive) return;
  if(!playerSnake || !playerSnake.alive) return;
  const hx = playerSnake.head.x, hy = playerSnake.head.y;
  for(const r of bossRockets){
    if(r.state !== 'idle') continue;
    const d = Math.hypot(r.x - hx, r.y - hy);
    if(d < Math.max(18, playerSnake.visualRadius*0.7) + 12){
      // only head triggers
      const dx = worldBoss.x - r.x, dy = worldBoss.y - r.y;
      const dist = Math.hypot(dx,dy) || 0.0001;
      const speed = (worldBoss.mode === DIFF_CLASSIFIED) ? 2.8 : 2.0; // slightly faster classified rockets
      const vx = (dx / dist) * speed;
      const vy = (dy / dist) * speed;
      bossProjectiles.push({ x: r.x, y: r.y, vx: vx, vy: vy, damage: worldBoss.rocketDamage });
      r.state = 'fired';
      for(let k=0;k<4;k++){ const angle = Math.random()*Math.PI*2; pellets.push({ x: r.x + Math.cos(angle)*6, y: r.y + Math.sin(angle)*6, color: '#ffd', created: Date.now(), value: 0.3 }); }
    }
  }
}

function checkPlayerBossCollision(){
  if(!worldBoss || !worldBoss.alive) return;
  if(!playerSnake) return;
  const hx = playerSnake.head.x, hy = playerSnake.head.y;
  const d = Math.hypot(hx - worldBoss.x, hy - worldBoss.y);
  if(d < worldBoss.radius + 24){
    killSnake(playerSnake, null, 'boss collision');
  }
}

// movement, collisions, etc. (kept mostly same)
function updateSnakeMovement(s, dt){ if(!s.alive) return; s.prevHead.x = s.head.x; s.prevHead.y = s.head.y; if(!s.isAI){ let vx=0, vy=0; if(keys.w || keys.ArrowUp) vy -= 1; if(keys.s || keys.ArrowDown) vy += 1; if(keys.a || keys.ArrowLeft) vx -= 1; if(keys.d || keys.ArrowRight) vx += 1; if(vx!==0 || vy!==0) s.head.angle = Math.atan2(vy, vx); } else aiThink(s); s.updateDisplaySpeed(dt); const speed = s.currentSpeed(); s.head.x += Math.cos(s.head.angle) * speed * dt; s.head.y += Math.sin(s.head.angle) * speed * dt; const maxCoord = MAP_HALF - BORDER_PADDING; s.head.x = Math.max(-maxCoord, Math.min(maxCoord, s.head.x)); s.head.y = Math.max(-maxCoord, Math.min(maxCoord, s.head.y)); for(const other of snakes){ if(other === s || !other.alive) continue; for(let k=4;k<other.segs.length;k+=Math.max(1, Math.floor(other.segs.length/40))){ const seg = other.segs[k]; const d = Math.hypot(s.head.x - seg.x, s.head.y - seg.y); const minDist = Math.max(6, other.visualRadius * 0.6); if(d < minDist){ s.head.x = s.prevHead.x; s.head.y = s.prevHead.y; const away = Math.atan2(s.head.y - seg.y, s.head.x - seg.x); s.head.angle = lerpAngle(s.head.angle, away, 0.8); s.displaySpeed *= 0.45; k = other.segs.length + 999; } } } if(!Array.isArray(s.segs)) s.segs = []; if(s.segs.length === 0) s.segs.push({ x:s.head.x, y:s.head.y }); const targetRendered = Math.min(s.segmentCount, MAX_RENDER_SEGS); s.segs[0] = { x: s.head.x, y: s.head.y }; const rawMult = Math.max(1, s.segmentCount / Math.max(1, targetRendered)); const spacingMultiplier = Math.min(rawMult, MAX_SPACING_MULT); const baseTarget = s.segSpacing(); const target = baseTarget * spacingMultiplier; while(s.segs.length < targetRendered) { const tail = s.segs[this.segs?this.segs.length-1:{x:s.head.x,y:s.head.y}] || {x:s.head.x,y:s.head.y}; s.segs.push({ x: tail.x, y: tail.y }); } if(s.segs.length > targetRendered) s.segs.length = targetRendered; for(let i=1;i<s.segs.length;i++){ const prev = s.segs[i-1], cur = s.segs[i]; const dx = prev.x - cur.x, dy = prev.y - cur.y; const dist = Math.hypot(dx,dy) || 0.0001; const nx = prev.x - (dx/dist)*target; const ny = prev.y - (dy/dist)*target; cur.x = cur.x + (nx - cur.x) * 0.92; cur.y = cur.y + (ny - cur.y) * 0.92; } s.updateRadii(dt); }

function checkCollisions(){ const b = MAP_HALF - BORDER_PADDING; const now = Date.now(); for(const s of snakes){ if(!s.alive) continue; if(Math.abs(s.head.x) > b || Math.abs(s.head.y) > b){ killSnake(s, null, 'boundary'); } } for(let i=0;i<snakes.length;i++){ const A = snakes[i]; if(!A.alive) continue; const ax0 = (A.prevHead && A.prevHead.x) || A.head.x; const ay0 = (A.prevHead && A.prevHead.y) || A.head.y; const ax1 = A.head.x, ay1 = A.head.y; const radAvis = A.visualRadius; for(let j=0;j<snakes.length;j++){ if(i===j) continue; const B = snakes[j]; if(!B.alive) continue; const radBvis = B.visualRadius; if((A.spawnInvulnerableUntil && now < A.spawnInvulnerableUntil) || (B.spawnInvulnerableUntil && now < B.spawnInvulnerableUntil)) continue; if(i < j){ const dxHH = A.head.x - B.head.x, dyHH = A.head.y - B.head.y; const dHH = Math.hypot(dxHH,dyHH); if(dHH < (radAvis + radBvis) * 0.95){ const dist = Math.max(0.0001, dHH); const nx = (B.head.x - A.head.x)/dist, ny = (B.head.y - A.head.y)/dist; const vAx = Math.cos(A.head.angle) * A.currentSpeed(); const vAy = Math.sin(A.head.angle) * A.currentSpeed(); const vBx = Math.cos(B.head.angle) * B.currentSpeed(); const vBy = Math.sin(B.head.angle) * B.currentSpeed(); const projA = vAx * nx + vAy * ny; const projB = -(vBx * nx + vBy * ny); const EPS = 0.14; if(projA > projB + EPS){ killSnake(B, A, 'head-to-head'); } else if(projB > projA + EPS){ killSnake(A, B, 'head-to-head'); } else { if((A === playerSnake && B.isAI) && (Math.random() < PLAYER_PRIORITY)) killSnake(B, A, 'head-to-head (player priority)'); else if((B === playerSnake && A.isAI) && (Math.random() < PLAYER_PRIORITY)) killSnake(A, B, 'head-to-head (player priority)'); else { if(Math.random() < 0.5) killSnake(A, B, 'head-to-head (random)'); else killSnake(B, A, 'head-to-head (random)'); } } continue; } } if(A === playerSnake && B.alive){ const segRad = Math.max(6, A.visualRadius); const headRad = radBvis; for(let si = 1; si < A.segs.length; si++){ const seg = A.segs[si]; const d = Math.hypot(seg.x - B.head.x, seg.y - B.head.y); if(d < segRad + headRad && !(B.spawnInvulnerableUntil && Date.now() < B.spawnInvulnerableUntil)){ killSnake(B, A, 'player body hit'); break; } } if(!B.alive) continue; } if(B === playerSnake && A.alive){ const segRad = Math.max(6, B.visualRadius); const headRad = radAvis; for(let si = 1; si < B.segs.length; si++){ const seg = B.segs[si]; const d = Math.hypot(seg.x - A.head.x, seg.y - A.head.y); if(d < segRad + headRad && !(A.spawnInvulnerableUntil && Date.now() < A.spawnInvulnerableUntil)){ killSnake(A, B, 'player body hit'); break; } } if(!A.alive) continue; } let skip = Math.max(1, Math.floor(B.segs.length / 120)); const minSkip = 1; if(skip < minSkip) skip = minSkip; for(let k=4;k<B.segs.length;k+= skip){ const seg = B.segs[k]; const dseg = pointToSegmentDistance(ax0,ay0,ax1,ay1, seg.x, seg.y); const threshold = Math.max(6, (radAvis + radBvis) * 0.62); if(dseg < threshold && !(Date.now() - (B.spawnTime || 0) < SPAWN_INVUL_MS)){ killSnake(A, B, 'body collision'); break; } } if(!A.alive) break; } } }

function tryFindSafeSpawn(strict=false){ const padding = Math.max(80, GRID_SIZE); for(let attempt=0;attempt<40;attempt++){ const x = (Math.random()*2-1) * (MAP_HALF - 700); const y = (Math.random()*2-1) * (MAP_HALF - 700); if(!isPointInAnyBody(x,y, padding)) return {x,y}; } if(strict) return null; return { x: (Math.random()*2-1) * (MAP_HALF - 700), y: (Math.random()*2-1) * (MAP_HALF - 700) }; }

function isPointInAnyBody(x,y, padding=0){ for(const s of snakes){ if(!s.alive) continue; for(let i=0;i<s.segs.length;i++){ const seg = s.segs[i]; const d = Math.hypot(seg.x - x, seg.y - y); const minDist = Math.max(12, s.visualRadius || BASE_RADIUS) + padding; if(d < minDist) return true; } } return false; }

function handleRespawns(){ const now = Date.now(); for(const s of snakes){ if(!s.alive && s.respawnAt && now >= s.respawnAt){ const pos = tryFindSafeSpawn(true); if(!pos){ s.respawnAt = Date.now() + 1500 + Math.floor(Math.random()*800); continue; } s.alive = true; s.head.x = pos.x; s.head.y = pos.y; s.head.angle = Math.random()*Math.PI*2; s.segs = []; s.spawnInvulnerableUntil = Date.now() + SPAWN_INVUL_MS; if(s._initialParams && s._initialParams.segmentCount && (s._initialParams.type === 'big' || s.type === 'big')){ const segCount = 900 + Math.floor(Math.random()*1600); s.segmentCount = segCount; s.thicknessMultiplier = s._initialParams.thicknessMultiplier || (2.0 + Math.random()*2.0); s.speedBase = Math.max(0.5, (4.2 + Math.random()*0.6) * 0.6); s.burstMultiplier = TOP_BURST_MULTIPLIER; s.type = 'big'; s.dodgeSkill = Math.min(0.99, (s.dodgeSkill || 0.75) + 0.18); s.aiStrength = (s.aiStrength || 0.9) + 0.18; s.bodyConsumeProb = Math.max(0.36, s.bodyConsumeProb || 0.28); } else { s.shrinkToSmall(); } const fill = Math.min(s.segmentCount, MAX_RENDER_SEGS); for(let i=0;i<fill;i++) s.segs.push({x:s.head.x,y:s.head.y}); s.respawnAt = 0; s.spawnTime = Date.now(); s.score = 0; showNotice((s.id || 'Player') + ' has respawned'); } } }

function drawMap(){ ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#e8f8e6'; ctx.fillRect(0,0,W,H); ctx.strokeStyle = 'rgba(140,190,160,0.6)'; ctx.lineWidth = 1; const left = camX - W/2 - GRID_SIZE, top = camY - H/2 - GRID_SIZE; const right = camX + W/2 + GRID_SIZE, bottom = camY + H/2 + GRID_SIZE; const startX = Math.floor(left / GRID_SIZE) * GRID_SIZE, startY = Math.floor(top / GRID_SIZE) * GRID_SIZE; ctx.beginPath(); for(let gx = startX; gx <= right; gx += GRID_SIZE){ const s = worldToScreen(gx, camY); ctx.moveTo(s.x, 0); ctx.lineTo(s.x, H); } for(let gy = startY; gy <= bottom; gy += GRID_SIZE){ const s = worldToScreen(camX, gy); ctx.moveTo(0, s.y); ctx.lineTo(W, s.y); } ctx.stroke(); const leftWorld = -MAP_HALF + BORDER_PADDING, topWorld = -MAP_HALF + BORDER_PADDING; const rightWorld = MAP_HALF - BORDER_PADDING, bottomWorld = MAP_HALF - BORDER_PADDING; const p1 = worldToScreen(leftWorld, topWorld), p2 = worldToScreen(rightWorld, bottomWorld); ctx.strokeStyle = 'rgba(255,60,60,0.98)'; ctx.lineWidth = 6; ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y); }

function drawPellets(){ for(const p of pellets){ const pos = worldToScreen(p.x, p.y); ctx.beginPath(); ctx.fillStyle = p.color || '#c2f087'; ctx.arc(pos.x, pos.y, PELLET_RADIUS, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.arc(pos.x - 2, pos.y - 2, Math.max(1, PELLET_RADIUS*0.28), 0, Math.PI*2); ctx.fill(); } }

function drawSnakes(){ for(const s of snakes){ if(!s.alive) continue; const rad = s.visualRadius; for(let i = s.segs.length - 1; i >= 0; i--){ const seg = s.segs[i]; const pos = worldToScreen(seg.x, seg.y); const alpha = 0.95 - (i / s.segs.length) * 0.5; ctx.fillStyle = colorWithAlpha(s.color, alpha); ctx.beginPath(); ctx.arc(pos.x, pos.y, rad, 0, Math.PI*2); ctx.fill(); } const headPos = worldToScreen(s.head.x, s.head.y); ctx.beginPath(); ctx.fillStyle = '#fff'; ctx.arc(headPos.x, headPos.y, Math.max(4, rad * 0.36), 0, Math.PI*2); ctx.fill(); const eyeOffset = rad * 0.46; const ex = headPos.x + Math.cos(s.head.angle) * eyeOffset, ey = headPos.y + Math.sin(s.head.angle) * eyeOffset; ctx.beginPath(); ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.arc(ex, ey, Math.max(2, rad*0.18), 0, Math.PI*2); ctx.fill(); ctx.font = '12px sans-serif'; ctx.fillStyle = '#111'; ctx.textAlign = 'center'; ctx.fillText(Math.floor(s.segmentCount), headPos.x, headPos.y - rad - 8); } }

function updateHUD(){ if(!playerSnake) return; const segs = Math.floor(playerSnake.segmentCount); const phys = Math.round(playerSnake._physRadius); const vis = Math.round(playerSnake.visualRadius); const spd = playerSnake.currentSpeed().toFixed(02); const eff = playerSnake.effectiveCount(); const pct = Math.round(clamp((eff / EFF_PER_GRID) * 100, 0, 100)); const progressBar = '<div class="progress-bar"><div class="progress-inner" style="width:'+pct+'%"></div></div>'; hud.innerHTML = 'Segments: <b>'+segs+'</b> / <b>'+playerSnake.segs.length+'</b> &nbsp; Radius: <b>'+phys+'</b> &nbsp; Speed: <b>'+spd+'</b><br> Progress to 1 grid: <b>'+pct+'%</b>' + progressBar; }

function updateLeaderboard(){ const arr = snakes.slice().filter(s=>s.alive).sort((a,b)=>b.segmentCount - a.segmentCount); let html = '<b>Leaderboard Top 5</b><br>'; for(let i=0;i<5;i++){ const s = arr[i]; if(!s) break; const name = s.id || ('Player'+(i+1)); html += (i+1) + '. ' + name + ' â€” ' + Math.floor(s.segmentCount) + '<br>'; } leaderboardEl.innerHTML = html; }

function attemptRespawn(){ if(playerSnake && !playerSnake.alive){ playerSnake.respawnAt = Date.now(); playerSnake.spawnTime = Date.now(); playerSnake.spawnInvulnerableUntil = Date.now() + SPAWN_INVUL_MS; showNotice('Attempting to respawn...'); } }
respawnBtn && respawnBtn.addEventListener('click', ()=>{ attemptRespawn(); });
respawnBtn && respawnBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); attemptRespawn(); });

function updateRespawnVisibility(){ if(window.innerWidth <= 900){ respawnBtn && respawnBtn.setAttribute('aria-hidden','false'); } else { respawnBtn && respawnBtn.setAttribute('aria-hidden','true'); } }
function updateRespawnBtnState(){ if(!respawnBtn) return; if(!playerSnake){ respawnBtn.style.display = (window.innerWidth<=900)?'block':'none'; respawnBtn.disabled = true; respawnBtn.style.opacity = 0.5; return; } if(window.innerWidth>900){ respawnBtn.style.display = 'none'; return; } if(!playerSnake.alive){ respawnBtn.style.display = 'block'; respawnBtn.disabled = false; respawnBtn.style.opacity = 1.0; } else { respawnBtn.style.display = 'block'; respawnBtn.disabled = true; respawnBtn.style.opacity = 0.55; } }

window.addEventListener('resize', updateRespawnVisibility); updateRespawnVisibility();

let lastTime = performance.now(), running = false; let noticeTimer = 0; let currentDifficulty = DIFF_REGULAR;
function mainLoop(now){ if(!running) return; try{ const dtRaw = now - lastTime; lastTime = now; const dt = Math.min(2.0, dtRaw / 16.666); for(const s of snakes){ if(s.alive) updateSnakeMovement(s, dt); } checkCollisions(); updatePelletPickup(); handleRespawns(); if(worldBoss && worldBoss.alive){ updateWorldBoss(dt); handleBossRocketTriggers(); checkPlayerBossCollision(); } if((currentDifficulty === DIFF_TOPSECRET || currentDifficulty === DIFF_CLASSIFIED) && playerSnake && playerSnake.segmentCount >= BOSS_TRIGGER_SEGMENTS && !worldBoss){ spawnWorldBoss(currentDifficulty, playerSnake.head.x + 600*Math.cos(playerSnake.head.angle), playerSnake.head.y + 600*Math.sin(playerSnake.head.angle)); }
  if(playerSnake){ camX += (playerSnake.head.x - camX) * 0.14; camY += (playerSnake.head.y - camY) * 0.14; }
  drawMap(); drawPellets(); drawSnakes(); drawWorldBoss(); updateLeaderboard(); if(hud && hud.style.display !== 'none') updateHUD(); updateRespawnBtnState(); if(noticeTimer && Date.now() > noticeTimer){ notice.style.display = 'none'; noticeTimer = 0; } debugErr.style.display = 'none'; }catch(err){ console.error('Main loop error:', err); debugErr.style.display = 'block'; debugErr.innerText = 'An error occurred (check console), continuingâ€¦'; } requestAnimationFrame(mainLoop); }

function initGame(opts){ snakes = []; pellets = []; worldBoss = null; bossRockets = []; bossProjectiles = []; PELLET_YIELD_MULT = 1.0; PELLET_TTL = 60 * 1000; PLAYER_PRIORITY = 0.9; PREFER_ATTACK_OTHERS = 0.62; currentDifficulty = (opts && opts.difficulty) ? opts.difficulty : DIFF_REGULAR;
  if(currentDifficulty === DIFF_TOPSECRET){ NUM_AI = 56; PELLET_YIELD_MULT = 0.45; PELLET_TTL = 20000; PLAYER_PRIORITY = 0.6; PREFER_ATTACK_OTHERS = 0.54; }
  else if(currentDifficulty === DIFF_CLASSIFIED){ NUM_AI = 52; PELLET_YIELD_MULT = 0.55; PELLET_TTL = 25000; PLAYER_PRIORITY = 0.62; PREFER_ATTACK_OTHERS = 0.56; }
  else { NUM_AI = 44; PELLET_YIELD_MULT = 0.95; PELLET_TTL = 50000; PLAYER_PRIORITY = 0.82; PREFER_ATTACK_OTHERS = 0.60; }

  const playerName = opts && opts.playerName ? opts.playerName : ('Player'+Math.floor(Math.random()*9000+1000));
  playerSnake = new Snake(playerName, 0, 0, '#2e8ef7', false);
  snakes.push(playerSnake);

  const useAI = opts && opts.settings ? !!opts.settings.allowAI : (NUM_AI>0);
  let aiCount = useAI ? NUM_AI : 0;
  aiCount = Math.min(aiCount, 120);

  const weightedCounts = [0,1,2,3,4];
  const probs = [0.35,0.45,0.15,0.04,0.01];
  function weightedSample(arr, ps){ const r=Math.random(); let acc=0; for(let i=0;i<arr.length;i++){ acc+=ps[i]; if(r<=acc) return arr[i]; } return arr[arr.length-1]; }

  const veryBigCount = weightedSample(weightedCounts, probs);
  let maxVeryBig = Math.min(INITIAL_BIG_SNAKES, veryBigCount);
  if(currentDifficulty === DIFF_TOPSECRET && Math.random() < 0.75) maxVeryBig = Math.max(0, maxVeryBig - 1);

  for(let i=0;i<maxVeryBig;i++){
    const pos = tryFindSafeSpawn();
    const x = pos.x, y = pos.y;
    const segCount = 1001 + Math.floor(Math.random()*1200);
    const thickness = 2.0 + Math.random() * 3.5;
    const intelRand = Math.random();
    const intelligenceLevel = intelRand < 0.65 ? 2 : (intelRand < 0.95 ? 3 : 4);
    const params = { type:'big', dodgeSkill: (intelligenceLevel===2?0.62:(intelligenceLevel===3?0.72:0.80)), bodyConsumeProb:0.25 + Math.random()*0.3, aiStrength:0.88 + Math.random()*0.2, thicknessMultiplier:thickness, segmentCount:segCount };

    if(currentDifficulty === DIFF_TOPSECRET){ params.aiStrength *= 1.25; params.dodgeSkill = Math.min(0.99, params.dodgeSkill + 0.08); params.bodyConsumeProb = Math.min(0.98, params.bodyConsumeProb * 1.6); }
    else if(currentDifficulty === DIFF_CLASSIFIED){ params.aiStrength *= 1.18; params.dodgeSkill = Math.min(0.99, params.dodgeSkill + 0.06); params.bodyConsumeProb = Math.min(0.95, params.bodyConsumeProb * 1.4); }

    const s = new Snake('VERY'+(i+1), x, y, randomColor(), true, params);
    s.speedBase = Math.max(0.5, s.speedBase * 0.7);
    s.burstMultiplier = TOP_BURST_MULTIPLIER;
    s.intelligenceLevel = intelligenceLevel;
    s.dodgeSkill = Math.min(0.99, (s.dodgeSkill || params.dodgeSkill || 0.7) + 0.08);
    s.aiStrength = (s.aiStrength || params.aiStrength || 0.95) + 0.14;
    s.bodyConsumeProb = Math.max(0.32, s.bodyConsumeProb || params.bodyConsumeProb || 0.28);
    s.burstMultiplier = (s.burstMultiplier || TOP_BURST_MULTIPLIER) * 1.18;
    snakes.push(s);
  }

  const tierParams = makeAITiers();
  let idx = 0;
  for(let i=0;i<aiCount-maxVeryBig;i++){
    const p = tierParams[idx++] || tierParams[idx % tierParams.length];
    const pos = tryFindSafeSpawn();
    const x = pos.x, y = pos.y;
    let thickness = 1.0;
    if(Math.random() < p.thicknessChance){ thickness = 1.2 + Math.random() * 1.6; }
    const paramsForSnake = { type: p.tier === 'basic' ? 'basic' : (p.tier === 'skilled' ? 'skilled' : (p.tier === 'top' ? 'top' : 'dumb')), dodgeSkill: p.dodgeSkill, bodyConsumeProb: p.bodyConsumeProb, aiStrength: p.aiStrength, thicknessMultiplier: thickness };
    if(p.tier === 'top'){ paramsForSnake.burstMultiplier = TOP_BURST_MULTIPLIER; }
    if(Math.random() < 0.14 && p.tier !== 'dumb'){ paramsForSnake.segmentCount = 200 + Math.floor(Math.random()*1200); }
    const playerInitLen = playerSnake.segmentCount || 18;
    if(paramsForSnake.segmentCount && paramsForSnake.segmentCount < Math.max(6, playerInitLen - 2)){ paramsForSnake.segmentCount = Math.max(6, playerInitLen - 2); }

    if(currentDifficulty === DIFF_TOPSECRET){ paramsForSnake.aiStrength = (paramsForSnake.aiStrength || 1.0) * 1.2; paramsForSnake.dodgeSkill = Math.min(0.99, (paramsForSnake.dodgeSkill || 0.7) + 0.08); paramsForSnake.bodyConsumeProb = Math.min(0.98, (paramsForSnake.bodyConsumeProb || 0.04) * 1.8); if(Math.random() < 0.08 && !paramsForSnake.segmentCount){ paramsForSnake.segmentCount = 160 + Math.floor(Math.random()*600); } }
    else if(currentDifficulty === DIFF_CLASSIFIED){ paramsForSnake.aiStrength = (paramsForSnake.aiStrength || 1.0) * 1.16; paramsForSnake.dodgeSkill = Math.min(0.99, (paramsForSnake.dodgeSkill || 0.7) + 0.06); paramsForSnake.bodyConsumeProb = Math.min(0.95, (paramsForSnake.bodyConsumeProb || 0.04) * 1.5); }
    else { paramsForSnake.aiStrength = (paramsForSnake.aiStrength || 1.0) * 1.04; }

    const s = new Snake('AI'+(i+1), x, y, randomColor(), true, paramsForSnake);
    if(s.segmentCount < Math.max(6, playerInitLen - 2)) s.segmentCount = Math.max(6, playerInitLen - 2);
    snakes.push(s);
  }

  const candidateCirclers = snakes.filter(s=>s.isAI && (s.type==='dumb' || s.type==='basic'));
  shuffleArray(candidateCirclers);
  const maxCirclers = 4;
  for(let i=0;i<Math.min(maxCirclers, candidateCirclers.length); i++){ candidateCirclers[i].isCircler = true; }

  leaderboardEl.style.display = 'block';
  hud.style.display = 'none';
  notice.style.display = 'none';
  camX = playerSnake.head.x; camY = playerSnake.head.y;
  showNotice('Game ready â€” good luck!');
}

// joystick kept
let joyActive = false; let joyCenter = {x:0,y:0}; let joyRadius = 44;
function showJoystick(){ if(joyWrap) { joyWrap.style.display = 'block'; joyWrap.setAttribute('aria-hidden','false'); } }
function hideJoystick(){ if(joyWrap) { joyWrap.style.display = 'none'; joyWrap.setAttribute('aria-hidden','true'); } resetJoy(); }
function resetJoy(){ if(joyKnob) joyKnob.style.transform = ''; joyActive = false; keys.w = keys.a = keys.s = keys.d = false; keys.ArrowUp = keys.ArrowLeft = keys.ArrowDown = keys.ArrowRight = false; }
joyToggle && joyToggle.addEventListener('change', ()=>{ if(joyToggle.checked) showJoystick(); else hideJoystick(); });
function updateJoyCenter(){ if(joyWrap){ const rect = joyWrap.getBoundingClientRect(); joyCenter.x = rect.left + rect.width/2; joyCenter.y = rect.top + rect.height/2; } } window.addEventListener('resize', updateJoyCenter); updateJoyCenter();
function handleJoyPointer(x,y, active){
  const dx = x - joyCenter.x; const dy = y - joyCenter.y;
  const dist = Math.hypot(dx,dy);
  const nx = dist > 0 ? dx / dist : 0; const ny = dist > 0 ? dy / dist : 0;
  const mag = Math.min(1, dist / joyRadius);
  if(joyKnob) joyKnob.style.transform = 'translate(' + (nx * Math.min(dist, joyRadius)) + 'px, ' + (ny * Math.min(dist, joyRadius)) + 'px)';
  const threshold = 0.28;
  if(mag < threshold || !active){ resetJoy(); return; }
  joyActive = true;
  const horiz = nx * mag; const vert = ny * mag;
  keys.w = vert < -0.25; keys.s = vert > 0.25; keys.a = horiz < -0.25; keys.d = horiz > 0.25;
}
if(joyWrap){
  joyWrap.addEventListener('touchstart', (e)=>{ e.preventDefault(); updateJoyCenter(); const t = e.touches[0]; handleJoyPointer(t.clientX, t.clientY, true); });
  joyWrap.addEventListener('touchmove', (e)=>{ e.preventDefault(); const t = e.touches[0]; handleJoyPointer(t.clientX, t.clientY, true); });
  joyWrap.addEventListener('touchend', (e)=>{ e.preventDefault(); resetJoy(); });
  let mouseDownOnJoy = false;
  joyWrap.addEventListener('mousedown', (e)=>{ e.preventDefault(); mouseDownOnJoy = true; updateJoyCenter(); handleJoyPointer(e.clientX, e.clientY, true); });
  window.addEventListener('mousemove', (e)=>{ if(!mouseDownOnJoy) return; handleJoyPointer(e.clientX, e.clientY, true); });
  window.addEventListener('mouseup', (e)=>{ if(mouseDownOnJoy){ mouseDownOnJoy = false; resetJoy(); } });
}

// start bindings (open difficulty modal)
function openDifficultyModal(){ if(difficultyBackdrop) difficultyBackdrop.style.display = 'flex'; } function closeDifficultyModal(){ if(difficultyBackdrop) difficultyBackdrop.style.display = 'none'; }

function safeStartGameBind(){
  const btn = document.getElementById('startBtn');
  if(!btn) return;
  btn.addEventListener('click', ()=> {
    try {
      openDifficultyModal();
    } catch(e){
      console.error('Start game error:', e);
      if(debugErr){ debugErr.style.display='block'; debugErr.innerText='Start game error: ' + (e && e.message ? e.message : e); }
      return;
    }
  });
}
if(document.readyState === 'loading'){
  window.addEventListener('DOMContentLoaded', safeStartGameBind);
} else safeStartGameBind();

diffRegular && diffRegular.addEventListener('click', ()=>{
  closeDifficultyModal();
  if(lobby) lobby.style.display = 'none';
  if(canvas){ canvas.style.display = 'block'; canvas.width = window.innerWidth; canvas.height = window.innerHeight; W = canvas.width; H = canvas.height; }
  try { initGame({playerName:'Player'+Math.floor(Math.random()*9000+1000), difficulty: DIFF_REGULAR}); running = true; lastTime = performance.now(); requestAnimationFrame(mainLoop); } catch(e){ console.error('initGame error (regular):', e); if(debugErr){ debugErr.style.display='block'; debugErr.innerText = 'Init error: ' + (e && e.message ? e.message : e); } }
});

diffClassified && diffClassified.addEventListener('click', ()=>{
  closeDifficultyModal();
  if(lobby) lobby.style.display = 'none';
  if(canvas){ canvas.style.display = 'block'; canvas.width = window.innerWidth; canvas.height = window.innerHeight; W = canvas.width; H = canvas.height; }
  try { initGame({playerName:'Player'+Math.floor(Math.random()*9000+1000), difficulty: DIFF_CLASSIFIED}); running = true; lastTime = performance.now(); requestAnimationFrame(mainLoop); } catch(e){ console.error('initGame error (classified):', e); if(debugErr){ debugErr.style.display='block'; debugErr.innerText = 'Init error: ' + (e && e.message ? e.message : e); } }
});

diffTopSecret && diffTopSecret.addEventListener('click', ()=>{
  closeDifficultyModal();
  if(lobby) lobby.style.display = 'none';
  if(canvas){ canvas.style.display = 'block'; canvas.width = window.innerWidth; canvas.height = window.innerHeight; W = canvas.width; H = canvas.height; }
  try { initGame({playerName:'Player'+Math.floor(Math.random()*9000+1000), difficulty: DIFF_TOPSECRET}); running = true; lastTime = performance.now(); requestAnimationFrame(mainLoop); } catch(e){ console.error('initGame error (topsecret):', e); if(debugErr){ debugErr.style.display='block'; debugErr.innerText = 'Init error: ' + (e && e.message ? e.message : e); } }
});

diffCancel && diffCancel.addEventListener('click', ()=>{ closeDifficultyModal(); });

window.addEventListener('load', ()=>{
  safeStartGameBind();
});

window.addEventListener('resize', ()=>{ canvas.width = window.innerWidth; canvas.height = window.innerHeight; W = canvas.width; H = canvas.height; updateJoyCenter(); updateRespawnVisibility(); });

leaderboardEl.style.display = 'none';
hud.style.display = 'none';
showNotice('Loaded â€” ready.');

</script>

</body>
</html>

